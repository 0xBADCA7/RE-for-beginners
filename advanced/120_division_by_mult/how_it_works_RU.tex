\subsection{Как это работает}

Вот как деление может быть заменено на умножение и деление на числа $2^{n}$:

\[
	result = 
	\frac{input}{divisor} = 
	\frac{input \cdot \frac{2^{n}}{divisor}}{2^{n}} = 
	\frac{input \cdot M}{2^{n}}
\]

Где $M$ это \IT{magic}-коэффициент.

Как вычислить $M$:

\[
	M = \frac{2^{n}}{divisor}
\]

Так что эти фрагменты кода обычно имеют форму:

\[
	result = \frac{input \cdot M}{2^{n}}
\]

Деление на $2^{n}$ производится обычным битовым сдвигом вправо.

Если $n<32$, тогда младшая 32-битная часть \glslink{product}{произведения} (в \EAX) сдвигается.
Если $n\geq{}32$, то тогда младшая 32-битная часть \glslink{product}{произведения} 
(в \EAX) просто игнорируется, и старшая 32-битная часть (в \EDX) сдвигается на $n-32$ бит вправо.

$n$ выбирается так, чтобы улучшить точность результата.

Если делать знаковое деление, знак результата умножения также добавляется к результату.

Посмотрите на разницу:

\begin{lstlisting}
int f3_32_signed(int a)
{
	return a/3;
};

unsigned int f3_32_unsigned(unsigned int a)
{
	return a/3;
};
\end{lstlisting}

В беззнаковой версии функции, \IT{magic}-коэффициент это \TT{0xAAAAAAAB} и результат умножения делится на $2^{33}$.

В знаковой версии функции, \IT{magic}-коэффициент это
 \TT{0x55555556} и результат умножения делится на $2^{32}$.
Впрочем здесь нет инструкции деления: результат просто берется из \EDX. 

Знак результата умножения также учитывается: старшие 32 бита результата сдвигаются на 31
(таким образом, оставляя знак в самом младшем бите \EAX).

1 прибавляется к конечному результату, если знак отрицательный, для коррекции результата.

\lstinputlisting[caption=\Optimizing MSVC 2012]{\CURPATH/2_RU.asm}

\subsubsection{Больше теории}

Это работает, потому что можно заменить деление на умножение вот так:

\[
	\frac{x}{c} = x\frac{1}{c}
\]


$\frac{1}{c}$ называется \IT{обратное число} и может быть вычислено компилятором на стадии компиляции.

Но это для вещественных чисел.
Что насчет целых чисел?

Можно найти \IT{обратное число по модулю} для целого числа в среде модульной арифметики
\footnote{\href{http://go.yurichev.com/17359}{Wikipedia}}.

Регистры \ac{CPU} подходят идеально: каждый ограничен 32 или 64-ю битами, так что практически любая арифметическая операция над регистрами это на самом деле операции по модулю $2^{32}$ или $2^{64}$.

Читайте больше об этом в \InSqBrackets{\HenryWarren 10-3}.

\section{Strings}
\label{sec:digging_strings}

\input{digging_into_code/strings/main_DE}

\subsection{Strings in Binär finden}

\myindex{UNIX!strings}
Das Standard UNIX \IT{strings} Utility ist ein quick-n-dirty Weg um alle Strings in der 
Datei an zu schauen. Zum Beispiel, in der OpenSSH 7.2 sshd executable Datei gibt es einige Strings:

\lstinputlisting{digging_into_code/sshd_strings.txt}

Dort kann man Optionen, Fehler Meldungen, Datei Pfade, importierte dynamische Module, Funktionen und einige andere komische 
Strings (keys?) sehen. Es gibt auch nicht druckbare Zeichen---x86 Code enthält chunks von druckbaren ASCII Zeichen, bis zu ca 8 Zeichen. % <-- bessere formulierung?

Sicher, OpenSSH ist ein open-source Programm.
Aber sich die lesbaren Strings eines unbekannten Programms an zuschauen ist meist der erste Schritt bei 
der Analyse. 
\myindex{UNIX!grep}

\IT{grep} kann genauso benutzt werden.

\myindex{Hiew}
\myindex{Sysinternals}
Hiew hat die gleichen Fähigkeiten (Alt-F6), genau wie der Sysinternals ProcessMonitor.

\subsection{Error/debug Narchichten}

Debugging Messages sind auch sehr nützlich, falls vorhanden.
Auf gewisse weise, melden die debugging messages was gerade
im Programm vorgeht. Oft schreiben diese \printf-like Funktionen, welche
in log-Dateien schreiben oder manchmal auch gar nichts schreiben aber die 
calls sind noch vorhanden, weil der build kein Debug build aber ein \IT{release} ist. % <-- nochmal über formulierung nachdenken
\myindex{\oracle}

Wenn lokale oder globale Variablen in Debug messages geschrieben werden, kann das auch 
hilfreich sein da man so an die Variablen Namen kommt. % <-- auch kacke geschrieben noch mal drüber nachdenken
Zum Beispiel, eine solche Funktion in \oracle ist \TT{ksdwrt()}.

Textstrings mit Aussage sind oft auch Hilfreich. %<-- der ist auch kacke
Der \IDA disassembler zeigt welche Funktion und von welchem Punkt aus ein spezifischer String benutzt wird.
Manchmal passieren lustige Dinge dabei\footnote{\href{http://go.yurichev.com/17223}{blog.yurichev.com}}.

Fehlermeldungen helfen uns genauso.
In \oracle, werden Fehler von einer Gruppe von Funktionen gemeldet.
Über das Thema kann man mehr hier erfahren: \href{http://go.yurichev.com/17224}{blog.yurichev.com}.

\myindex{Error messages}

Es ist Möglich heraus zu finden welche Funktionen Fehler melden und unter welchen Bedingungen.


Übrigens, das ist für Kopierschutztsysteme oft der Grund kryptische Fehlermeldungen oder einfach nur 
Fehlernummer aus zu geben. Niemand ist glücklich darüber wenn der Softwarecracker den Kopierschutz besser
versteht nur weil dieser durch eine Fehlermeldung ausgelöst wurde.

Ein Beispiel von verschlüsselten Fehlermeldungen gibt es hier: \myref{examples_SCO}.

\subsection{Verdächtige magic strings}

Manche Magic Strings welche in Hintertüren benutzt werden sehen schon ziemlich verdächtig aus.


Zum Beispiel, es gab eine Hintertür im TP-Link WR740 Home Router\footnote{\url{http://sekurak.pl/tp-link-httptftp-backdoor/}}.
Die Hintertür konnte aktiviert werden wenn man folgende URL aufrief:
\url{http://192.168.0.1/userRpmNatDebugRpm26525557/start_art.html}.\\

Tatsächlich, kann man den Magic String \q{userRpmNatDebugRpm26525557} in der Firmware finden.

Der String war nicht googlebar bis die Information öffentlich über die Hintertür öffentlich verbreitet wurde.


Man würde solche Informationen natürlich auch nicht in irgendeinem \ac{RFC} finden.


Man würde auch keinen Informatik Algorithmus finden der solch seltsame Byte Sequenzen benutzt.


Und es sieht auch nicht nach einer Fehler- order Debugnaricht aus.


Also es ist immer eine gute Idee so seltsame Dinge genauer zu betrachten.\\
\\
\myindex{base64}

Manchmal, sind solche Strings auch mit base64 codiert.

Es ist also immer eine gute Idee diese Stings zu Decodieren und sie visuell zu durchsuchen, ein Blick
kann schon genügen.

\\
\myindex{Security through obscurity}
Präziser gesagt, diese Methode Hintertüren zu verstecken nennt man \q{security through obscurity}.

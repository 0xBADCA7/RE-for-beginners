\section{Suspicious code patterns}

\subsection{XOR instructions}
\myindex{x86!\Instructions!XOR}

Instruktionen wie \TT{XOR op, op} (zum Beispiel, \TT{XOR EAX, EAX})
werden normal dafür benutzt Register Werte auf Null zu setzen, wenn jedoch
einer der Operanden sich unterscheidet wird die \q{exclusive or} Operation 
ausgeführt.

Diese Operation wird allgemein selten benutzt beim programmieren, ist aber 
weit verbreitet in der Kryptografie, besonders bei Amateuren der Kryptografie. % <-- Bessere formulierung?
Das ist besonders Verdächtig wenn der zweite Operand eine große Zahl ist.

% This operation is rare in common programming, but widespread in cryptography,
% including amateur one.
% It's especially suspicious if the
% second operand is a big number.

Das könnte ein Hinweis sein das etwas ver-/entschlüsselt wird oder Checksumme berechnet werden, etc.\\
\\

Eine Ausnahme dieser Beobachtung ist der \q{canary} (\myref{subsec:BO_protection}). 
Die Generierung und das prüfen des \q{canary} werden oft mit Hilfe der \XOR Instruktion gemacht. \\
\\


\myindex{AWK}

Dieses AWK Skript kann benutzt werden um \IDA{} listing (.lst) Dateien zu parsen:

\begin{lstlisting}
gawk -e '$2=="xor" { tmp=substr($3, 0, length($3)-1); if (tmp!=$4) if($4!="esp") if ($4!="ebp") { print $1, $2, tmp, ",", $4 } }' filename.lst
\end{lstlisting}

Es sollte auch noch erwähnt werden das diese Art von Skript in der Lage ist inkorrekt disassemblierten Code zu erkennen
(\myref{sec:incorrectly_disasmed_code}).

\subsection{Hand-written assembly code}

\myindex{Function prologue}
\myindex{Function epilogue}
\myindex{x86!\Instructions!LOOP}
\myindex{x86!\Instructions!RCL}

Moderne Compiler benutzen keine \TT{LOOP} und \TT{RCL} Instruktionen.
Auf der anderen Seite sind diese Instruktionen sehr beliebt bei Programmieren die Code direkt in Assembler schreiben.
Wenn man diese Instruktionen sieht, kann man mit hoher Sicherheit sagen das dieses Code Fragment händisch geschrieben wurde.,
Diese Instruktionen sind in der Instruktionsliste im Anhang mit (M) markiert: \myref{sec:x86_instructions}.

\par

Auch die Funktions Prolog und Epilog sind im allgemeinen nicht vorhanden bei handgeschriebenen Assembler Code. % <--- ??? 
% Also the function prologue/epilogue are not commonly present in hand-written assembly.
\par

Tatsächlich gibt es kein bestimmtes System um Argumente an Funktionen zu übergeben wenn der Code handgeschrieben wurde. 

\par
Beispiel aus dem Windows 2003 Kernel
(ntoskrnl.exe file):

\begin{lstlisting}[style=customasmx86]
MultiplyTest proc near               ; CODE XREF: Get386Stepping
             xor     cx, cx
loc_620555:                          ; CODE XREF: MultiplyTest+E
             push    cx
             call    Multiply
             pop     cx
             jb      short locret_620563
             loop    loc_620555
             clc
locret_620563:                       ; CODE XREF: MultiplyTest+C
             retn
MultiplyTest endp

Multiply     proc near               ; CODE XREF: MultiplyTest+5
             mov     ecx, 81h
             mov     eax, 417A000h
             mul     ecx
             cmp     edx, 2
             stc
             jnz     short locret_62057F
             cmp     eax, 0FE7A000h
             stc
             jnz     short locret_62057F
             clc
locret_62057F:                       ; CODE XREF: Multiply+10
                                     ; Multiply+18
             retn
Multiply     endp
\end{lstlisting}

Tatsächlich, wenn wir in den 
\ac{WRK} v1.2 source code schauen,
kann dieser Code einfach in der Datei
\IT{WRK-v1.2\textbackslash{}base\textbackslash{}ntos\textbackslash{}ke\textbackslash{}i386\textbackslash{}cpu.asm} gefunden werden.

\chapter{Finden von wichtigen/ interessanten Stellen im Code}

Minimalismus ist kein beliebtes feature von moderner Software.
% Minimalism it is not a prominent feature of modern software.

\myindex{\Cpp!STL}

Aber nicht weil die Programmierer so viel Code schreiben, sondern weil die libaries allgemein statisch zu ausführbaren
Dateien gelinkt werden. 
Wenn alle externen libraries in externe DLL Dateien verschoben werden würden wäre die Welt ein anderer Ort.
(Ein weiterer grund für C++ sind die \ac{STL} und andere template libraries.)

% But not because the programmers are writing a lot, but because a lot of libraries are commonly linked statically
% to executable files.
% If all external libraries were shifted into an external DLL files, the world would be different.
% (Another reason for C++ are the \ac{STL} and other template libraries.)

\newcommand{\FOOTNOTEBOOST}{\footnote{\url{http://go.yurichev.com/17036}}}
\newcommand{\FOOTNOTELIBPNG}{\footnote{\url{http://go.yurichev.com/17037}}}

Deshalb ist es sehr wichtig den ursprung einer Funktion zu bestimmen, wenn die Funktuion aus 
einer Standart library oder aus einer sehr bekannten library stammt (wie z.B Boost\FOOTNOTEBOOST, libpng\FOOTNOTELIBPNG),
oder ob die Funktion sich auf das bezieht was wir im Code versuchen zu finden.

% Thus, it is very important to determine the origin of a function, if it is from standard library or 
% well-known library (like Boost\FOOTNOTEBOOST, libpng\FOOTNOTELIBPNG),
% or if it is related to what we are trying to find in the code.

Es ist ein wenig absurd sämtlichen code neu zu schreiben in \CCpp um das zu finden 
was wir suchen.
% It is just absurd to rewrite all code in \CCpp to find what we're looking for.

Eine der Hauptaufgaben eines Reverse Enigneers ist es schnell den Code zu finden den er/sie sucht. % <-- nachbessern (formulierung) ?
% One of the primary tasks of a reverse engineer is to find quickly the code he/she needs.

\myindex{\GrepUsage}

Der \IDA disassembler erlaubt uns durch Text Strings, Byte sqeuenzen und konstanten zu suchen. % <-- noch mal? 
Es ist sogar möglich den code in .lst oder .asm Text dateien zu exporiteren und diese mit \TT{grep}, \TT{awk}, etc. zu untersuchen.

% The \IDA disassembler allow us to search among text strings, byte sequences and constants.
% It is even possible to export the code to .lst or .asm text files and then use \TT{grep}, \TT{awk}, etc.

Wenn man versucht zu verstehen wie ein bestimmter Code funtkioniert, kann es auch einfach eine open-source library wie libpng sein. % <-- kling scheisse, noch mal über den Sinn nachdenken?!
Wenn man also eine Konstante oder Textstrings findet die vertraut erscheinen, ist es immer einen Versuch wert diese zu \IT{google}n .
Und wenn man ein Opensource Project findet in dem diese Funktion benutzt wird, 
reicht es meist aus diese Funktionen miteinander zu vergleichen.
Es könnte helfen Teile des Problems zu lösen.

% When you try to understand what some code is doing, this easily could be some open-source library like libpng.
% So when you see some constants or text strings which look familiar, it is always worth to \IT{google} them.
% And if you find the opensource project where they are used, 
% then it's enough just to compare the functions.
% It may solve some part of the problem.

Zum Beispiel, wenn ein Programm XML dateien benutzt, wäre der erste Schritt zu ermitteln welche
XML library benutzt wird für die verarbeitung, da die Standart (oder am weitesten verbreitete) libraries
normal benutzt werden anstatt selbst geschriebene librarys.

% For example, if a program uses XML files, the first step may be determining which
% XML library is used for processing, since the standard (or well-known) libraries are usually used
% instead of self-made one.

\myindex{SAP}
\myindex{Windows!PDB}

Zum Beispiel, der Author dieser Zeilen wollte verstehen wie die kompression/dekomprission von Netzwerkpaketen in SAP 6.0 funktioniert.
SAP ist ein gewaltiges Stück Software, aber detailierte -\gls{PDB} Dateien mit debugging Informationen sind vorhanden, was sehr praktisch 
ist. Der Author hat schliesslich eine Ahnung gehabt, das eine Funktion genannt \IT{CsDecomprLZC} die dekompression der Netzwerkpakete übernahm.
Er hat den Namen der Funtkion gegoogled und ist schnell darauf gekommen das diese Funktion in MaxDB benutzt wurde
(Das ist ein Open-Source SAP Projekt) \footnote{Mehr darüber in der relevanten Sektion~(\myref{sec:SAPGbUI})}. 

% For example, the author of these lines once tried to understand how the compression/decompression of network packets works in SAP 6.0. 
% It is a huge software, but a detailed .\gls{PDB} with debugging information is present, 
% and that is convenient.
% He finally came to the idea that one of the functions, that was called \IT{CsDecomprLZC}, was doing the decompression of network packets.
% Immediately he tried to google its name and he quickly found the function was used in MaxDB
% (it is an open-source SAP project) \footnote{More about it in relevant section~(\myref{sec:SAPGbUI})}.

\url{http://www.google.com/search?q=CsDecomprLZC}

Erstaunlich, das MaxDB und die SAP 6.0 Software den selben code geteilt haben für die Kompression/Dekompression der Netzwerkpakete.
% Astoundingly, MaxDB and SAP 6.0 software shared likewise code for the compression/decompression of network packets.

\input{digging_into_code/identification/exec_EN}

% binary files might be also here

\section{Communication with outer world (function level)}
Oft ist es empfehlenswert die Funktions Argumente und die Rückgabewerte im Debugger oder \ac{DBI} zu überwachen.
Zum Beispiel, einmal hat der Author versucht die bedeutung einer obscuren Funktion zu verstehen, die einen inkorrekten
Bubble sort algorithmus implementiert hatte. (Sie hat funktioniert, jedoch langsamer.) 
Zwischenzeitlich, die Eingaben und Ausgaben der Funktion zu überwachen hilft instant zu verstehen was die Funktion tut.

% It's often advisable to track function arguments and return values in debugger or \ac{DBI}.
% For example, the author once tried to understand meaning of some obscure function, which happens to be incorrectly
% implemented bubble sort.
% (It worked correctly, but slower.)
% Meanwhile, watching inputs and outputs of this function helps instantly to understand what it does.%

% The following input files each one has to be also translated!
\input{digging_into_code/communication_win32_EN}
\input{digging_into_code/strings_EN}\input{digging_into_code/strings_RU}
\input{digging_into_code/assert_EN}
\input{digging_into_code/constants_EN}
\input{digging_into_code/instructions_EN}
\input{digging_into_code/suspicious_code_EN}
\input{digging_into_code/magic_numbers_tracing_EN}

\section{Other things}

\subsection{General idea}

Ein Reverse Engineer sollte versuchen so oft wie Möglich in den Schuhen des Programmierers zu laufen.
Um ihren/seinen Standpunkt zu betrachten uns sich selbst zu Fragen wie man einen Task in spezifischen Fällen lösen würde.

% A reverse engineer should try to be in programmer's shoes as often as possible. 
% To take his/her viewpoint and ask himself, how would one solve some task the specific case.

\subsection{Order of functions in binary code}

Sämmtliche Funktionen die in einer einzelenen .c oder .cpp-file gefunden werden, werden zu den entsprechenden Object Datein (.o) kompiliert. 
Später, fügt der Linker alle Objektdatein die er braucht zusammen, ohne die Reihenfolge oder die Funktionen in Ihnen zu verändern. 
Als eine Konsequenz, ergibt sich daraus wenn man zwei oder mehr aufeinanderfolgende Funktionen sieht, bedeutet dass das sie in der 
gleichen Source code Datei plaziert waren ( Ausser natürlich man bewegt sich an der Genze zwischen zwei Datein. ).  Das bedetet
das diese Funktionen etwas gemeinsam haben, das sie aus dem gleichen \ac{API} Level stammen oder aus der gleichen library, etc.

% All functions located in a single .c or .cpp-file are compiled into corresponding object (.o) file.
% Later, linker puts all object files it needs together, not changing order or functions in them.
% As a consequence, if you see two or more consecutive functions, it means, that they were placed together
% in a single source code file (unless you're on border of two object files, of course.)
% This means these functions have something in common, that they are from the same \ac{API} level, from same library, etc.

\subsection{Tiny functions}

Sehr kleine oder leere Funktionen  (\myref{empty_func})
oder Funtkionen die nur ``true'' (1) oder ``false'' (0) (\myref{ret_val_func}) sind weit verbreitet,
und fast jeder ordentlicher Kompiler tendiert dazu nur solche Funktionen in den resultierenden ausführbaren code zu stecken,
sogar wenn es mehrere gleiche Funktionen im Source Code bereits gibt. 
Also, wann immer man solche kleinen Funtkionen sieht die z.B nur aus \TT{mov eax, 1 / ret} bestehen und von mehreren 
Orten aus referenziert werden (und aufgerufen werden können), und scheinbar keine Verbindung zu einander haben, dann 
ist das warscheinlich das Ergebnis einer Optimisierung. 

% Tiny functions like empty functions (\myref{empty_func})
% or function which returns just ``true'' (1) or ``false'' (0) (\myref{ret_val_func}) are very common,
% and almost all decent compiler tends put only one such function into resulting executable code even if there was several
% similar functions in source code.
% So, whenever you see a tiny function consisting just of \TT{mov eax, 1 / ret}
% which is referenced (and can be called) from many places,
% which are seems unconnected to each other, this may be a result of such optimization.%

\subsection{\Cpp}

\ac{RTTI}~(\myref{RTTI})-data ist vielleicht auch nützlich für die \Cpp klassen identifikation.
% \ac{RTTI}~(\myref{RTTI})-data may be also useful for \Cpp class identification.

% sections
% DE Translation also needed for subfiles here
\input{digging_into_code/binary/main_EN}
\input{digging_into_code/snapshots_comparing_EN}


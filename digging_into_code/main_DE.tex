\chapter{Finden von wichtigen/ interessanten Stellen im Code}

Minimalismus ist kein beliebtes Feature von moderner Software.

\myindex{\Cpp!STL}

Aber nicht weil die Programmierer so viel Code schreiben, sondern weil die libaries allgemein statisch zu ausführbaren
Dateien gelinkt werden. 
Wenn alle externen libraries in externe DLL Dateien verschoben werden würden wäre die Welt ein anderer Ort.
(Ein weiterer Grund für C++ sind die \ac{STL} und andere template libraries.)

\newcommand{\FOOTNOTEBOOST}{\footnote{\url{http://go.yurichev.com/17036}}}
\newcommand{\FOOTNOTELIBPNG}{\footnote{\url{http://go.yurichev.com/17037}}}

Deshalb ist es sehr wichtig den Ursprung einer Funktion zu bestimmen, wenn die Funktion aus 
einer Standard library oder aus einer sehr bekannten library stammt (wie z.B Boost\FOOTNOTEBOOST, libpng\FOOTNOTELIBPNG),
oder ob die Funktion sich auf das bezieht was wir im Code versuchen zu finden.

Es ist ein wenig absurd sämtlichen Code neu zu schreiben in \CCpp um das zu finden 
was wir suchen.

Eine der Hauptaufgaben eines Reverse Enigneers ist es schnell den Code zu finden den er/sie sucht. % <-- nachbessern (formulierung) ?
% One of the primary tasks of a reverse engineer is to find quickly the code he/she needs.

\myindex{\GrepUsage}

Der \IDA disassembler erlaubt uns durch Text Strings, Byte Sequenzen und konstanten zu suchen. % <-- noch mal? 
Es ist sogar möglich den Code in .lst oder .asm Text Dateien zu exportieren und diese mit \TT{grep}, \TT{awk}, etc. zu untersuchen.

% The \IDA disassembler allow us to search among text strings, byte sequences and constants.
% It is even possible to export the code to .lst or .asm text files and then use \TT{grep}, \TT{awk}, etc.

Wenn man versucht zu verstehen wie ein bestimmter Code funktioniert, kann es auch einfach eine open-source library wie libpng sein. % <-- kling scheisse, noch mal über den Sinn nachdenken?!
Wenn man also eine Konstante oder Textstrings findet die vertraut erscheinen, ist es immer einen Versuch wert diese zu \IT{google}n .
Und wenn man ein Opensource Projekt findet in dem diese Funktion benutzt wird, 
reicht es meist aus diese Funktionen miteinander zu vergleichen.
Es könnte helfen Teile des Problems zu lösen.

% When you try to understand what some code is doing, this easily could be some open-source library like libpng.
% So when you see some constants or text strings which look familiar, it is always worth to \IT{google} them.
% And if you find the opensource project where they are used, 
% then it's enough just to compare the functions.
% It may solve some part of the problem.

Zum Beispiel, wenn ein Programm XML Dateien benutzt, wäre der erste Schritt zu ermitteln welche
XML library benutzt wird für die Verarbeitung, da die Standard (oder am weitesten verbreitete) libraries
normal benutzt werden anstatt selbst geschriebene librarys.

\myindex{SAP}
\myindex{Windows!PDB}

Zum Beispiel, der Autor dieser Zeilen wollte verstehen wie die Kompression/Dekompression von Netzwerkpacketen in SAP 6.0 funktioniert.
SAP ist ein gewaltiges Stück Software, aber detaillierte -\gls{PDB} Dateien mit Debug Informationen sind vorhanden, was sehr praktisch 
ist. Der Autor hat schließlich eine Ahnung gehabt, das eine Funktion genannt \IT{CsDecomprLZC} die Dekompression der Netzwerkpackete übernahm.
Er hat nach dem Namen der Funktion auf google gesucht und ist schnell zum schluss gekommen das diese Funktion in 
MaxDB benutzt wurde (Das ist ein Open-Source SAP Projekt) \footnote{Mehr darüber in der relevanten Sektion~(\myref{sec:SAPGbUI})}. 

\url{http://www.google.com/search?q=CsDecomprLZC}

Erstaunlich, das MaxDB und die SAP 6.0 Software den selben Code geteilt haben für die Kompression/Dekompression der Netzwerkpackete.

\input{digging_into_code/identification/exec_EN} % <-- Auf exec_DE umbiegen

\section{Kommunikation mit der außen Welt (Funktion Level)} % <-- übersetzen
Oft ist es empfehlenswert die Funktion Argumente und die Rückgabe werte im Debugger oder \ac{DBI} zu überwachen.
Zum Beispiel, einmal hat der Autor versucht die Bedeutung einer obskuren Funktion zu verstehen, die einen inkorrekten
Bubble sort Algorithmus implementiert hatte. (Sie hat funktioniert, jedoch langsamer.) 
Zwischenzeitlich, die Eingaben und Ausgaben der Funktion zu überwachen hilft instand zu verstehen was die Funktion tut.

% The following input files each one has to be also translated! 
% Folgende auf DE umbiegen
\input{digging_into_code/communication_win32_DE}
\input{digging_into_code/strings_DE}\input{digging_into_code/strings_RU}
\input{digging_into_code/assert_DE}
\input{digging_into_code/constants_DE}
\input{digging_into_code/instructions_DE}
\input{digging_into_code/suspicious_code_DE}
\input{digging_into_code/magic_numbers_tracing_DE}

\section{Andere Dinge}  % <-- übersetzen

\subsection{Die Idee}  % <-- übersetzen

Ein Reverse Engineer sollte versuchen so oft wie Möglich in den Schuhen des Programmierers zu laufen.
Um ihren/seinen Standpunkt zu betrachten uns sich selbst zu Fragen wie man einen Task in spezifischen Fällen lösen würde.

\subsection{Anordnung von Funktionen in Binär Code}  % <-- übersetzen

Sämtliche Funktionen die in einer einzelnen .c oder .cpp-Datei gefunden werden, werden zu den entsprechenden Objekt Dateien (.o) kompiliert. Später, fügt der Linker alle Objektdatein die er braucht zusammen, ohne die Reihenfolge oder die Funktionen in Ihnen zu verändern. Als eine Konsequenz, ergibt sich daraus wenn man zwei oder mehr aufeinander folgende Funktionen sieht, bedeutet dass das sie in der gleichen Source Code Datei platziert waren ( Ausser natürlich man bewegt sich an der Grenze zwischen zwei Dateien. ).  Das bedeutet
das diese Funktionen etwas gemeinsam haben, das sie aus dem gleichen \ac{API} Level stammen oder aus der gleichen library, etc.

\subsection{kleine Funktionen}  % <-- übersetzen

Sehr kleine oder leere Funktionen  (\myref{empty_func})
oder Funktionen die nur ``true'' (1) oder ``false'' (0) (\myref{ret_val_func}) sind weit verbreitet,
und fast jeder ordentlicher Compiler tendiert dazu nur solche Funktionen in den resultierenden ausführbaren Code zu stecken,
sogar wenn es mehrere gleiche Funktionen im Source Code bereits gibt. 
Also, wann immer man solche kleinen Funktionen sieht die z.B nur aus \TT{mov eax, 1 / ret} bestehen und von mehreren 
Orten aus referenziert werden (und aufgerufen werden können), und scheinbar keine Verbindung zu einander haben, dann 
ist das wahrscheinlich das Ergebnis einer Optimierung. 

\subsection{\Cpp}

\ac{RTTI}~(\myref{RTTI})-data ist vielleicht auch nützlich für die \Cpp Klassen Identifikation.

% sections
% DE Translation also needed for subfiles here
\input{digging_into_code/binary/main_DE}
\input{digging_into_code/snapshots_comparing_DE}


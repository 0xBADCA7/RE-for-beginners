\subsection{Einfaches Beispiel}

% subsections
\input{patterns/09_loops/simple/x86}
\input{patterns/09_loops/simple/ARM/main}
\input{patterns/09_loops/simple/MIPS}

\subsubsection{Eine Sache noch}
Im generierten Code sehen wir folgendes:
<<<<<<< HEAD
nach der Initialisierung von $i$ wird der Körper der Schleife nicht ausgeführt,
da die Bedingung für $i$ zuerst geprüft wird und erst danach der Körper der
Schleife ausgeführt werden kann. Und so ist es auch korrekt.

Denn, falls die Bedingung zu Beginn falsch ist, darf der Körper der Schleife nie
ausgeführt werden. 
Dies ist z.B. im folgenden Fall möglich:
=======
nach der Initialisierung von $i$ wird der KÃ¶rper der Schleife nicht ausgefÃ¼hrt,
da die Bedingung fÃ¼r $i$ zuerst geprÃ¼ft wird und erst danach der KÃ¶rper der
Schleife ausgefÃ¼hrt werden kann. Und so ist es auch korrekt.

Denn, falls die Bedingung zu Beginn falsch ist, darf der KÃ¶rper der Schleife nie
ausgefÃ¼hrt werden. 
Dies ist z.B. im folgenden Fall mÃ¶glich:
>>>>>>> 33058039def6268466867db95246998137625356


\lstinputlisting[style=customc]{patterns/09_loops/simple/loops_3_DE.c}

<<<<<<< HEAD
Wenn \IT{total\_entries\_to\_process} gleich 0 ist, darf der Körper der Schleife
auf keinen Fall ausgeführt werden. 

Deshalb wird die Bedingung stets vor der Ausführung geprüft. 

Ein optimierter Compiler kann jedoch das Prüfen der Bedingung und den
Schleifenkörper vertauschen, falls sichergestellt ist, dass die hier
=======
Wenn \IT{total\_entries\_to\_process} gleich 0 ist, darf der KÃ¶rper der Schleife
auf keinen Fall ausgefÃ¼hrt werden. 

Deshalb wird die Bedingung stets vor der AusfÃ¼hrung geprÃ¼ft. 

Ein optimierter Compiler kann jedoch das PrÃ¼fen der Bedingung und den
SchleifenkÃ¶rper vertauschen, falls sichergestellt ist, dass die hier
>>>>>>> 33058039def6268466867db95246998137625356
beschriebene Situation auf keinen Fall eintreten kann (wie in unserem sehr
einfachen Beispiel und bei Keil, Xcode (LLVM), MSVC im optimierten Modus).


\subsubsection{MIPS}

\myparagraph{初期化されていないグローバル変数}

だから今$x$変数はグローバルです。 
オブジェクトファイルではなく実行ファイルにコンパイルし、 \IDA にロードしてみましょう。 
IDAは、\IT{.sbss} ELFセクションに$x$変数を表示します（25ページの\q{グローバルポインタ} \myref{MIPS_GP}を覚えておいてください）。
これは変数が最初に初期化されていないためです。

\lstinputlisting[caption=\Optimizing GCC 4.4.5 (IDA),style=customasmMIPS]{patterns/04_scanf/2_global/MIPS/O3_IDA_JPN.lst}

IDAは情報量を減らすため、objdumpを使用してリスティングを行い、コメントします。

\lstinputlisting[caption=\Optimizing GCC 4.4.5 (objdump),numbers=left,style=customasmMIPS]{patterns/04_scanf/2_global/MIPS/O3_objdump_JPN.txt}

今度は$x$変数アドレスがGPを使って64KiBのデータバッファから読み込まれ、負のオフセットが加えられていることがわかります（18行目）。 
さらに、この例（ \puts 、 \scanf 、 \printf ）で使用されている3つの外部関数のアドレスもGPを使用して64KiBグローバルデータバッファから読み込まれます（9,16,26行目） 。 
GPはバッファの中央を指しています。このようなオフセットは、
3つの関数のアドレスと$x$変数のアドレスがすべてそのバッファの先頭に格納されていることを示しています。 
私たちの例は非常に小さいので、それは理にかなっています。

\myindex{MIPS!\Pseudoinstructions!MOVE}
\myindex{MIPS!\Pseudoinstructions!NOP}

言及する価値がある別のことは、次の関数の開始を16バイトの境界に合わせるために、関数が2つの\ac{NOP}（\TT{MOVE \$AT,\$AT}、アイドル命令）で終了することです。

\myparagraph{初期化されたグローバル変数}

$x$変数にデフォルト値を与えることで、この例を変更しましょう。

\lstinputlisting[style=customc]{patterns/04_scanf/2_global/default_value_EN.c}

IDAは$x$変数が.dataセクションに存在することを示しています：

\lstinputlisting[caption=\Optimizing GCC 4.4.5 (IDA),style=customasmMIPS]{patterns/04_scanf/2_global/MIPS/O3_IDA_init_JPN.lst}

Why not .sdata? Perhaps that this depends on some GCC option?

Nevertheless, now $x$ is in .data, which is a general memory area, and we can take a look
how to work with variables there.

\myindex{MIPS!\Instructions!LUI}
\myindex{MIPS!\Instructions!ADDIU}

The variable's address must be formed using a pair of instructions.

In our case those are \INS{LUI} (\q{Load Upper Immediate}) and \INS{ADDIU} (\q{Add Immediate Unsigned Word}).

Here is also the objdump listing for close inspection:

\lstinputlisting[caption=\Optimizing GCC 4.4.5 (objdump),style=customasmMIPS]{patterns/04_scanf/2_global/MIPS/O3_objdump_init_JPN.txt}

\myindex{MIPS!\Instructions!LUI}
\myindex{MIPS!\Instructions!ADDIU}
\myindex{MIPS!\Instructions!LW}

We see that the address is formed using \INS{LUI} and \INS{ADDIU}, but the high part of address is still in
the \$S0 register, and it is possible to encode the offset in a \INS{LW} (\q{Load Word}) instruction, so one single \INS{LW} is enough 
to load a value from the variable and pass it to \printf.

Registers holding temporary data are prefixed with T-, but here we also see some prefixed with S-, 
the contents of which must be preserved before use in other functions (i.e., saved somewhere).
% FIXME:
% This needs to be clarified a bit, e.g. "the registers need to be preserved if a function is called and it wants to use them

That is why the value of \$S0 has been set at address 0x4006cc and has been used again
at address 0x4006e8, after the \scanf call. 
The \scanf function does not change its value.

% TODO non-optimized example?

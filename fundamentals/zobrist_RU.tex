\subsection{Хэширование Зобриста / табуляционное хэширование}

Если вы работаете над шахматным движком, вы проходите по дереву вариантов много раз в секунду, и часто, вы встречаете
ту же позицию, которая уже была обработана.

Так что вам нужно использовать какой-нибудь метод для хранения где-то уже просчитанных позиций.
Но шахматная позиция требует много памяти, и лучше бы использовать хэш-функцию.

Вот способ сжать шахматную позицию в 64-битное значение, называемый хэширование Зобриста:

\begin{lstlisting}[style=customc]
// у нас доска 8*8 и 12 фигур (6 для белых и 6 для черных)

uint64_t table[12][8][8]; // заполнено случайными значениями

int position[8][8]; // для каждой клетки на доске. 0 - нет фигуры, 1..12 - фигура

uint64_t hash;

for (int row=0; row<8; row++)
	for (int col=0; col<8; col++)
	{
		int piece=position[row][col];

		if (piece!=0)
			hash=hash^table[piece][row][col];
	};

return hash;
\end{lstlisting}

Теперь самая интересная часть: если следующая (модифицированная) шахматная позиция отличается только одной (перемещенной)
фигурой, вам не нужно пересчитывать хэш для всей позиции, все что вам нужно, это:

\begin{lstlisting}[style=customc]
hash=...; // (уже посчитано)

// вычесть информацию о старой фигуре:
hash=hash^table[old_piece][old_row][old_col];

// добавить информацию о новой фигуре:
hash=hash^table[new_piece][new_row][new_col];
\end{lstlisting}


% TODO TikZ
\ifdefined\RUSSIAN
\newcommand{\HashFuncChapterName}{Хеш-функции}
\section{\HashFuncChapterName}
\label{hash_func}

\myindex{\HashFuncChapterName}
\myindex{CRC32}
Простейший пример это CRC32, алгоритм \q{более мощный} чем простая контрольная сумма,
для проверки целостности данных.
Невозможно восстановить оригинальный текст из хеша, там просто меньше информации: ведь текст
может быть очень длинным, но результат CRC32 всегда ограничен 32 битами.
Но CRC32 не надежна в криптографическом смысле: известны методы как изменить текст таким образом,
чтобы получить нужный результат.
Криптографические хеш-функции защищены от этого. \\
\\
\myindex{MD5}
\myindex{SHA1}
Такие функции как MD5, SHA1, итд, широко используются для хеширования паролей
для хранения их в базе.
Действительно: БД форума в интернете может и не хранить пароли 
(иначе злоумышленник получивший доступ к БД сможет узнать все пароли), а только хеши.
К тому же, скрипту интернет-форума вовсе не обязательно знать ваш пароль, он только должен
сверить его хеш с тем что лежит в БД, и дать вам доступ если cверка проходит.
Один из самых простых способов взлома --- это просто перебирать все пароли и ждать пока
результат будет такой же как тот что нам нужен.
Другие методы намного сложнее.
% TODO1 add about Rainbow tables

\subsection{Как работает односторонняя функция?}

Односторонняя функция, это функция, которая способна превратить из одного значения другое,
при этом невозможно (или трудно) проделать обратную операцию.
Некоторые люди имеют трудности с пониманием, как это возможно.
Рассмотрим очень простой пример.

У нас есть ряд из 10-и чисел в пределах 0..9, каждое встречается один раз, например:

\begin{lstlisting}
4 6 0 1 3 5 7 8 9 2
\end{lstlisting}

Алгоритм простейшей односторонней функции выглядит так:

\begin{itemize}
\item возьми число на нулевой позиции (у нас это 4);
\item возьми число на первой позиции (у нас это 6);
\item обменяй местами числа на позициях 4 и 6.
\end{itemize}

Отметим числа на позициях 4 и 6:

\begin{lstlisting}
4 6 0 1 3 5 7 8 9 2
        ^   ^
\end{lstlisting}

Меняем их местами и получаем результат:

\begin{lstlisting}
4 6 0 1 7 5 3 8 9 2
\end{lstlisting}

Глядя на результат, и даже зная алгоритм функции, мы не можем однозначно восстановить изначальное
положение чисел.
Ведь первые два числа могли быть 0 и/или 1, и тогда именно они могли бы участвовать в обмене.

Это крайне упрощенный пример для демонстрации, настоящие односторонние функции могут быть значительно сложнее.
\fi % RUSSIAN

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\ifdefined\ENGLISH
\newcommand{\HashFuncChapterName}{%
	\EN{Hash functions}%
}
\section{\HashFuncChapterName}
\label{hash_func}

\myindex{\HashFuncChapterName}
\myindex{CRC32}
A very simple example is CRC32, an algorithm that provides \q{stronger} checksum for integrity checking purposes.
It is impossible to restore the original text from the hash value, it has much less information:
But CRC32 is not cryptographically secure: it is known how to alter a text in a way that the resulting
CRC32 hash value will be the one we need.
Cryptographic hash functions are protected from this. \\
\\
\myindex{MD5}
\myindex{SHA1}
MD5, SHA1, etc. are such functions and they are widely used to hash user passwords in order to store them in a database.
Indeed: an Internet forum database may not contain user passwords 
(a stolen database can compromise all users' passwords) but only hashes 
(so a cracker can't reveal the passwords).
Besides, an Internet forum engine does not need to know your password exactly, it needs only to check if its hash
is the same as the one in the database, and give you access if they match.
One of the simplest password cracking methods is just to try hashing all possible passwords in order
to see which matches the resulting value that we need.
Other methods are much more complex.
% TODO1 add about Rainbow tables

\subsection{How do one-way functions work?}

A one-way function is a function which is able to transform one value into another,
while it is impossible (or very hard) to reverse it.
Some people have difficulties while understanding how this is possible at all.
Here is a simple demonstration.

We have a vector of 10 numbers in range 0..9, each is present only once, for example:

\begin{lstlisting}
4 6 0 1 3 5 7 8 9 2
\end{lstlisting}

The algorithm for the simplest possible one-way function is:

\begin{itemize}
\item take the number at zeroth position (4 in our case);
\item take the number at first position (6 in our case);
\item swap numbers at positions of 4 and 6.
\end{itemize}

Let's mark the numbers at positions 4 and 6:

\begin{lstlisting}
4 6 0 1 3 5 7 8 9 2
        ^   ^
\end{lstlisting}

Let's swap them and we get this result:

\begin{lstlisting}
4 6 0 1 7 5 3 8 9 2
\end{lstlisting}

While looking at the result, and even if we know the algorithm, we can't know unambiguously the initial
state, because the first two numbers could be 0 and/or 1, and then they could participate in the swapping procedure.

This is an utterly simplified example for demonstration. Real one-way functions are much more complex.
\fi % ENGLISH

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\ifdefined\SPANISH
\newcommand{\HashFuncChapterName}{Funciones hash}

\section{\HashFuncChapterName}
\label{hash_func}

\myindex{\HashFuncChapterName}
\myindex{CRC32}
Un ejemplo muy sencillo es CRC32, un algoritmo que provee una \q{fuerte} suma de
comprobaci\'on para prop\'ositos de comprobaci\'on de integridad.
Es imposible reestablecer el texto original a partir de su valor hash, tiene mucho menos informaci\'on:
la entrada puede ser larga, pero el resultado de CRC32 siempre est\'a limitado a 32 bits.
Pero CRC32 no es criptogr\'aficamente seguro: es sabido c\'omo alterar un texto de tal modo que el valor
del hash CRC32 resultante sea el que necesitemos.
Las funciones hash criptogr\'aficas est\'an protegidas de esto. \\
\\
\myindex{MD5}
\myindex{SHA1}
Tales funciones son MD5, SHA1, etc., y son utilizadas ampliamente para obtener el hash de contrase\~nas de usuarios para
almacenarlas en las bases de datos.
De hecho, la base de datos de un foro en internet no puede contener las contrase\~nas de los usuarios
(una base de datos robado puede comprometer las contrase\~nas de todos los usuarios) sino \'unicamente
hashes (un cracker no puede recuperar las contrase\~nas).
Adem\'as, el motor de un foro de internet no es consciente de tu contrase\~na, s\'olo debe comprobar
si su hash es el mismo que aquel almacenado en la base de datos, y darte acceso si concuerdan.
Uno de los m\'etodos de cracking de contrase\~nas m\'as simple es tratar de obtener los hashes de todas
las contrase\~nas posibles para ver cu\'al concuerda con el resultado que necesitamos.
Otros m\'etodos son mucho m\'as complejos.
% TODO1 add about Rainbow tables

\subsection{?`C\'omo trabajan las funciones de una v\'ia?}

Las funciones de una v\'ia son funciones capces de transformar un valor en otro,
a la vez que es imposible (o muy dif\'icil revertirlo.)
Algunas personas tienen dificultad entendiendo c\'omo puede ser esto posible.
Consideremos una demostraci\'on simple.

Tenemos un vector de 10 n\'umeros en el rango 0..9, cada una presente una sola vez, por ejemplo:

\begin{lstlisting}
4 6 0 1 3 5 7 8 9 2
\end{lstlisting}

El algoritmo de la funci\'on de una v\'ia m\'as simple es:

\begin{itemize}
\item toma el n\'umero en la posici\'on cero (4 en nuestro caso);
\item toma el n\'umero en la primera posici\'on (6 en nuestro caso);
\item intercambia los n\'umeros en las posiciones 4 y 6.
\end{itemize}

Marquemos los n\'umeros en las posiciones 4 y 6:

\begin{lstlisting}
4 6 0 1 3 5 7 8 9 2
        ^   ^
\end{lstlisting}

Intercambi\'emolos y tenemos el resultado:

\begin{lstlisting}
4 6 0 1 7 5 3 8 9 2
\end{lstlisting}

Mientras vemos el resultado, incluso si conocemos el algoritmo, no podemos enumerar sin ambig\"uedad el conjunto inicial
porque los primeros dos n\'umeros puedieron haber sido 0 y/o 1, y puedieron haber participado en el proceso de intercambio.

Este ejemplo fue demasiado simplificado para efectos de desmostraci\'on. Las funciones de una v\'ia reales pueden llegar a ser muy complejas.
\fi % SPANISH


